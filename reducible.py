"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, <Jorge Nunez> and <Vivian Zhang>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: jn29423
UT EID 2: wz5363
"""
import sys
# the constant used to calculate the step size
STEP_SIZE_CONSTANT = 3


# DO NOT modify this function.
def is_prime(n):
    """
    Determines if a number is prime.

    pre: n is a positive integer.
    post: Returns True if n is prime, otherwise returns False.
    """
    if n == 1:
        return False

    limit = int(n**0.5) + 1
    div = 2
    while div < limit:
        if n % div == 0:
            return False
        div += 1
    return True


# DO NOT modify this function.
def hash_word(s, size):
    """
    Hashes a lowercase string to an index in a hash table.

    pre: s is a lowercase string, and size is a positive integer representing either
         hash table size or the constant for double hashing.
    post: Returns an integer index in the range [0, size - 1] where the string hashes to.
    """
    # *26 makes it so that anagrams dont hash to the same value
    # the entire string has one hash index it is mapped to
    hash_idx = 0
    for c in s:
        letter = ord(c) - 96
        hash_idx = (hash_idx * 26 + letter) % size
    return hash_idx


# TODO: Modify this function. You may delete this comment when you are done.
def step_size(s):
    """
    Calculates step size for double hashing using STEP_SIZE_CONSTANT.

    pre: s is a lowercase string.
    post: Returns the calculated step size as an integer based on the provided string.
    """

    # Prime number is a prime value less than the length of hash list
    # equation is defined as prime number - (key % prime number)
    # Key is the hash index, which is returned from the hash_word function
    # Step size is defined as 3 (constant)
    hash_idx = hash_word(s, STEP_SIZE_CONSTANT)
    step = STEP_SIZE_CONSTANT - (hash_idx % STEP_SIZE_CONSTANT)
    return step

# TODO: Modify this function. You may delete this comment when you are done.
def insert_word(s, hash_table):
    """
    Inserts a string into the hash table using double hashing for collision resolution.
    No duplicates are allowed.

    pre: s is a string, and hash_table is a list representing the hash table.
    post: Inserts s into hash_table at the correct index; resolves any collisions
          by double hashing.
    """
    size = len(hash_table)
    index = hash_word(s, size)
    step = step_size(s)
    new_index = index
    if hash_table[index] == "":
        hash_table[index] = s

    # Issues are when you double hash and you reach a filled spot again
    else:
        while hash_table[new_index] != "":
            # accounts for duplicates
            if hash_table[new_index] == s:
                break
            new_index = (index + step) % size
            index = new_index
        hash_table[new_index] = s

# TODO: Modify this function. You may delete this comment when you are done.
def find_word(s, hash_table):
    """
    Searches for a string in the hash table.
    Note: using the `in` operator is incorrect as that will be O(N). We want
          an O(1) time average time complexity using hashing.

    pre: s is a string, and hash_table is a list representing the hash table.
    post: Returns True if s is found in hash_table, otherwise returns False.
    """
    # Calculate hashing index
    # Look at that specific index - if the string is not in that
    # index, then return false
    size = len(hash_table)
    counter = size
    index = hash_word(s, size)
    step = step_size(s)
    new_index = index
    # if there are no collisions
    if s == hash_table[index]:
        return True
    # if there are collisions--need to find double hash index and check that
    while hash_table[new_index] != "":
        if s == hash_table[new_index]:
            return True
        new_index = (new_index + step) % size
        # to prevent infinite loop of going through the hash table over and over again
        counter -= 1
        if counter == 0: # looked through everything already
            break
    return False



def is_reducible(s, hash_table, hash_memo):
    """
    Determines if a string is reducible using a recursive check.

    pre: s is a lowercase string, hash_table is a list representing the hash table,
         and hash_memo is a list representing the hash table
         for memoization.
    post: Returns True if s is reducible (also updates hash_memo by
          inserting s if reducible), otherwise returns False.
    """

    # Create a sub-word by removing a letter from the word (find a way to
    # Remove any letter from the word
    # If the word is valid, then start using this word with recursion and continue the first step

    # Once a word is determined to be reducible, find a way to recursively go back to the word and
    # store all sub words of the first word, since once we find any of these sub-words in
    # Other words we know they are reducible.

    # Maybe for each recursive call, you can store all removed characters and
    # their respective index in a list, then re-add them to the word and keep
    # adding these words to the hash_memo

    # Probably involves a double recursive call

    original_word = s
    def reducible_helper(s, hash_table, hash_memo):

        # Immediately return true if at any point, the word is found in the hash memo
        if find_word(s, hash_memo):
            return True

        # Return if the string is s or o or i, do not append to hash memo
        if s in ("i", "o", "a") and len(s) == 1:
            return True

        # Return False if you reach a length of 1 and the word does not reduce to the
        # 3 letters s, i, or o
        if len(s) == 1:
            return False

        # Loop through all possible combinations of the word by removing a letter
        length = len(s)
        for i in range(length):
            new_word = s[:i] + s[(i+1):]
            if find_word(new_word, hash_table):
                if reducible_helper(new_word, hash_table, hash_memo):
                    insert_word(s, hash_memo)
                    return True
        return False
    #for _ in range(orig_length):
    return reducible_helper(original_word, hash_table, hash_memo)

def get_longest_words(string_list):
    """
    Finds longest words from a list.

    pre: string_list is a list of lowercase strings.
    post: Returns a list of words in string_list that have the maximum length.
    """
    str_list= []
    longest_length = 0
    for elem in string_list:
        longest_length = max(longest_length, len(elem))
    for word in string_list:
        if len(word) == longest_length:
            str_list.append(word)
    return str_list


def main():
    """The main function that calculates the longest reducible words"""
    # create an empty word_list
    word_list = []
    # read words using input redirection
    # where each line read from input()
    # should be a single word. Append to word_list
    # ensure each word has no trailing white space.
    for line in sys.stdin:
        word_list.append(line.strip())
    # find length of word_list
    len_wordlist = len(word_list)
    # determine prime number N that is greater than twice
    # the length of the word_list

    # Initializing prime_num and looping
    prime_num = len_wordlist * 2
    while not is_prime(prime_num):
        prime_num += 1

    # create an empty hash_list
    # populate the hash_list with N blank strings
    hash_list = [""] * prime_num

    # hash each word in word_list into hash_list
    for word in word_list:
        insert_word(word, hash_list)

    # create an empty hash_memo of size M
    # we do not know a priori how many words will be reducible
    # let us assume it is 10 percent (fairly safe) of the words
    # then M is a prime number that is slightly greater than
    # 0.2 * size of word_list
    # populate the hash_memo with M blank strings
    len_memo = .2 * len_wordlist
    while not is_prime(len_memo):
        len_memo += 1
    hash_memo = [""] * len_memo
    # create an empty list reducible_words
    reducible_words = []
    for word in word_list:
        if is_reducible(word, hash_list, hash_memo):
            reducible_words.append(word)
    # find the largest reducible words in reducible_words
    largest_words = get_longest_words(reducible_words)
    # print the reducible words in alphabetical order from list
    # one word per line
    largest_words.sort()
    for word in largest_words:
        print(word)

if __name__ == "__main__":
    main()
